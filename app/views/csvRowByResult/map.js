// Generated by CoffeeScript 1.6.2
(function(doc) {
  var bySubtest, clone, datetimeCount, datetimeSuffix, exportValue, exportValueMap, i, item, keyId, label, linearOrder, metaData, metaKey, metaKeys, monthData, months, newData, observationData, observations, optionKey, optionValue, orderMap, pair, prototype, rawIndex, row, startTime, subtest, subtestData, subtestIndex, surveyValue, surveyVariable, variableName, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _n, _ref, _ref1, _ref2, _ref3, _ref4, _results;

  subtest = {};
  if (doc.collection === "result") {
    clone = function (item) {
        if (!item) { return item; } // null, undefined values check

        var types = [ Number, String, Boolean ], 
            result;

        // normalizing primitives if someone did new String('aaa'), or new Number('444');
        types.forEach(function(type) {
            if (item instanceof type) {
                result = type( item );
            }
        });

        if (typeof result == "undefined") {
            if (Object.prototype.toString.call( item ) === "[object Array]") {
                result = [];
                item.forEach(function(child, index, array) { 
                    result[index] = clone( child );
                });
            } else if (typeof item == "object") {
                // testing that this is DOM
                if (item.nodeType && typeof item.cloneNode == "function") {
                    var result = item.cloneNode( true );    
                } else if (!item.prototype) { // check that this is a literal
                    if (item instanceof Date) {
                        result = new Date(item);
                    } else {
                        // it is an object literal
                        result = {};
                        for (var i in item) {
                            result[i] = clone( item[i] );
                        }
                    }
                } else {
                    // depending what you would like here,
                    // just keep the reference, or create new object
                    if (false && item.constructor) {
                        // would not advice to do that, reason? Read below
                        result = new item.constructor();
                    } else {
                        result = item;
                    }
                }
            } else {
                result = item;
            }
        }

        return result;
    };
    subtestData = doc.subtestData;
    keyId = doc.assessmentId;
    if (doc.klassId != null) {
      keyId = doc.klassId;
      newData = clone(doc.subtestData);
      newData["variable_name"] = doc.itemType + "_" + doc.reportType + "_" + doc.part + "_";
      subtestData = [
        {
          data: newData,
          prototype: doc.prototype,
          subtestId: doc.subtestId
        }
      ];
      log("NEW SUBTEST DATA");
      log(JSON.stringify(subtestData));
    }
    exportValueMap = {
      "correct": 1,
      "checked": 1,
      "incorrect": "0",
      "unchecked": "0",
      "missing": ".",
      "not_asked": ".",
      "skipped": 999
    };
    metaKeys = ["enumerator", "start_time", "order_map"];
    exportValue = function(databaseValue) {
      if (databaseValue == null) {
        databaseValue = "no_record";
      }
      if (exportValueMap[databaseValue] != null) {
        return exportValueMap[databaseValue];
      } else {
        return String(databaseValue);
      }
    };
    pair = function(key, value) {
      var o;

      if (value === void 0) {
        value = "no_record";
      }
      o = {};
      o[key] = value;
      return o;
    };
    metaData = [];
    for (_i = 0, _len = metaKeys.length; _i < _len; _i++) {
      metaKey = metaKeys[_i];
      if (doc[metaKey] != null) {
        metaData.push(pair(metaKey, doc[metaKey]));
      }
    }
    startTime = doc['starttime'] || doc['start_time'];
    metaData.push(pair("start_time", startTime));
    metaData.push(pair("order_map", doc['order_map'] != null ? doc['order_map'].join(",") : "no_record"));
    bySubtest = {
      "meta_data": metaData
    };
    datetimeCount = 0;
    linearOrder = (function() {
      _results = [];
      for (var _j = 0, _ref = subtestData.length - 1; 0 <= _ref ? _j <= _ref : _j >= _ref; 0 <= _ref ? _j++ : _j--){ _results.push(_j); }
      return _results;
    }).apply(this);
    orderMap = doc["order_map"] != null ? doc["order_map"] : doc["orderMap"] ? doc["orderMap"] : linearOrder;
    for (_k = 0, _len1 = linearOrder.length; _k < _len1; _k++) {
      rawIndex = linearOrder[_k];
      row = [];
      subtestIndex = orderMap.indexOf(rawIndex);
      subtest = subtestData[subtestIndex];
      if (subtest == null) {
        log("skipped empty subtest");
        log(doc);
        continue;
      }
      if (subtest.data == null) {
        log("skipped subtest with null data");
        log(doc);
        continue;
      }
      prototype = subtest.prototype;
      if (prototype === "id") {
        row.push(pair("id", subtest.data.participant_id));
      } else if (prototype === "location") {
        _ref1 = subtest.data.labels;
        for (i = _l = 0, _len2 = _ref1.length; _l < _len2; i = ++_l) {
          label = _ref1[i];
          row.push(pair(label, subtest.data.location[i]));
        }
      } else if (prototype === "datetime") {
        months = ["jan", "feb", "mar", "apr", "may", "jun", "jul", "aug", "sep", "oct", "nov", "dec"];
        if (~months.indexOf(subtest.data.month.toLowerCase())) {
          monthData = months.indexOf(subtest.data.month.toLowerCase()) + 1;
        } else {
          monthData = subtest.data.month;
        }
        datetimeSuffix = datetimeCount > 0 ? "_" + datetimeCount : "";
        row.push(pair("year" + datetimeSuffix, subtest.data.year));
        row.push(pair("month" + datetimeSuffix, monthData));
        row.push(pair("date" + datetimeSuffix, subtest.data.day));
        row.push(pair("assess_time" + datetimeSuffix, subtest.data.time));
        datetimeCount++;
      } else if (prototype === "consent") {
        row.push(pair("consent", subtest.data.consent));
      } else if (prototype === "grid") {
        variableName = subtest.data.variable_name;
        row.push(pair("" + variableName + "_auto_stop", subtest.data.auto_stop));
        row.push(pair("" + variableName + "_time_remain", subtest.data.time_remain));
        row.push(pair("" + variableName + "_attempted", subtest.data.attempted));
        row.push(pair("" + variableName + "_item_at_time", subtest.data.item_at_time));
        row.push(pair("" + variableName + "_time_intermediate_captured", subtest.data.time_intermediate_captured));
        _ref2 = subtest.data.items;
        for (i = _m = 0, _len3 = _ref2.length; _m < _len3; i = ++_m) {
          item = _ref2[i];
          row.push(pair("" + variableName + (i + 1), exportValue(item.itemResult)));
        }
      } else if (prototype === "survey") {
        _ref3 = subtest.data;
        for (surveyVariable in _ref3) {
          surveyValue = _ref3[surveyVariable];
          if (surveyValue === Object(surveyValue)) {
            for (optionKey in surveyValue) {
              optionValue = surveyValue[optionKey];
              row.push(pair("" + surveyVariable + "_" + optionKey, exportValue(optionValue)));
            }
          } else {
            row.push(pair(surveyVariable, exportValue(surveyValue)));
          }
        }
      } else if (prototype === "observation") {
        _ref4 = subtest.data.surveys;
        for (i = _n = 0, _len4 = _ref4.length; _n < _len4; i = ++_n) {
          observations = _ref4[i];
          observationData = observations.data;
          for (surveyVariable in observationData) {
            surveyValue = observationData[surveyVariable];
            if (surveyValue === Object(surveyValue)) {
              for (optionKey in surveyValue) {
                optionValue = surveyValue[optionKey];
                row.push(pair("" + surveyVariable + "_" + optionKey + "_" + (i + 1), exportValue(optionValue)));
              }
            } else {
              row.push(pair("" + surveyVariable + "_" + (i + 1), exportValue(surveyValue)));
            }
          }
        }
      } else if (prototype === "gps") {
        row.push(pair("latitude", subtest.data.lat));
        row.push(pair("longitude", subtest.data.long));
        row.push(pair("accuracy", subtest.data.acc));
        row.push(pair("altitude", subtest.data.alt));
        row.push(pair("altitudeAccuracy", subtest.data.altAcc));
        row.push(pair("heading", subtest.data.heading));
        row.push(pair("speed", subtest.data.speed));
        row.push(pair("timestamp", subtest.data.timestamp));
      } else if (prototype === "complete") {
        row.push(pair("additional_comments", subtest.data.comment));
        row.push(pair("end_time", subtest.data.end_time));
      }
      row.push(pair("time_stamp_" + (rawIndex + 1), subtest.timestamp));
      bySubtest[subtest.subtestId] = row;
    }
    return emit(keyId, bySubtest);
  }
});
